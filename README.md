# Cartesian Product Builder

A builder which constructs the Cartesian product of two or more sequences of
objects. 

The Cartesian product of _n_ sequences consists of all possible
combinations in which the first element of the comhination is taken from the first 
sequence, the second element from the second sequence, and so on to the _nth_ 
element which is taken from the _nth_ sequence.

For example, the Cartesian product of the sequences _(A,B)_, _(C,D)_ and _(E,F)_ 
consists of the following eight combinations:
* _(A, C, E)_
* _(A, C, F)_
* _(A, D, E)_
* _(A, D, F)_
* _(B, C, E)_
* _(B, C, F)_
* _(B, D, E)_
* _(B, D, F)_

## Usage

A Cartesian product builder is created using a fluent API, where the first sequence
to be used is specified by calling the static method `CartesianProductBuilder.of()`, 
and each subsequent sequence by calling the `and()` instance method of the result
of the previous call. The minimum number of such calls is two (that is, 
`CartesianProduct.of(...).and(...)`), after which the 
Cartesian product can be generated by calling the instance method `build()`.

For example, the builder that operates on the sequences shown above would be 
invoked as

```java
Stream<Combination> product = CartesianProductBuilder.of(A, B)
   .and(C, D)
   .and(E, F)
   .build();
```

Each sequence of objects can be specified as a `Collection`, a `Stream`, an
array, or individually (a varargs argument). For example, to use the objects `x`, `y` and `z` as the first sequence any of the following might be used:

```java
CartesianProductBuilder.of(x, y, z)
CartesianProductBuilder.of(str)   // str = Stream.of(x, y, z)
CartesianProductBuilder.of(arr}   // arr = new Object[] {x, y, z}
CartesianProductBuilder.of(lst)   // lst = Arrays.asList(x, y, z)
```

A Cartesian product that is built using this builder is of type `Stream<Combination>`,
where each combination is a single element of the Cartesian product. The Combination
is essentially an iterator, which allows the elements of the combination to be
accessed in turn. Each element is stored as an `Object`, but methods are provided
to access the next element as any object type, or any of the primitive types `int`,
`long`, `double` or `boolean`. Note that attempting to cast the next element
to an invalid type will throw an exception, as will trying to access the next 
element after all elements have been accessed; it is assumed that this will not
generally be a problem, as the number and types of the elements will be known.